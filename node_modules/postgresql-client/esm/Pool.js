import { Pool as LightningPool } from 'lightning-pool';
import { coerceToBoolean, coerceToInt } from 'putil-varhelpers';
import { ConnectionState, } from './definitions';
import { getConnectionConfig } from './util/connection-config';
import { SafeEventEmitter } from './SafeEventEmitter';
import { Connection } from './Connection';
import { IntlConnection } from './IntlConnection';
import { getIntlConnection } from './common';
import _debug from 'debug';
const debug = _debug('pgc:connection');
export class Pool extends SafeEventEmitter {
    constructor(config) {
        super();
        const cfg = getConnectionConfig(config);
        this.config = Object.freeze(cfg);
        const poolOptions = {};
        poolOptions.acquireMaxRetries = coerceToInt(cfg.acquireMaxRetries, 0);
        poolOptions.acquireRetryWait = coerceToInt(cfg.acquireRetryWait, 2000);
        poolOptions.acquireTimeoutMillis = coerceToInt(cfg.acquireTimeoutMillis, 0);
        poolOptions.idleTimeoutMillis = coerceToInt(cfg.idleTimeoutMillis, 30000);
        poolOptions.max = coerceToInt(cfg.max, 10);
        poolOptions.maxQueue = coerceToInt(cfg.maxQueue, 1000);
        poolOptions.max = coerceToInt(cfg.max, 10);
        poolOptions.min = coerceToInt(cfg.min, 0);
        poolOptions.minIdle = coerceToInt(cfg.minIdle, 0);
        poolOptions.validation = coerceToBoolean(cfg.validation, false);
        const poolFactory = {
            create: async () => {
                const intlCon = new IntlConnection(cfg);
                await intlCon.connect();
                intlCon.on('close', () => this._pool.destroy(intlCon));
                debug('created connection %s', intlCon.processID);
                return intlCon;
            },
            destroy: intlCon => {
                debug('destroy connection %s', intlCon.processID);
                return intlCon.close();
            },
            reset: async (intlCon) => {
                debug('reset connection %s', intlCon.processID);
                try {
                    if (intlCon.state === ConnectionState.READY)
                        await intlCon.execute('ROLLBACK;');
                }
                finally {
                    intlCon.removeAllListeners();
                    intlCon.once('close', () => this._pool.destroy(intlCon));
                    intlCon._refCount = 0;
                }
            },
            validate: async (intlCon) => {
                debug('validate connection %s', intlCon.processID);
                if (intlCon.state !== ConnectionState.READY)
                    throw new Error('Connection is not active');
                await intlCon.execute('select 1;');
            },
        };
        this._pool = new LightningPool(poolFactory, poolOptions);
        this._pool.on('return', (...args) => this.emit('release', ...args));
        this._pool.on('error', (...args) => this.emit('error', ...args));
        this._pool.on('acquire', (...args) => this.emit('acquire', ...args));
        this._pool.on('destroy', (...args) => this.emit('destroy', ...args));
        this._pool.start();
    }
    /**
     * Returns number of connections that are currently acquired
     */
    get acquiredConnections() {
        return this._pool.acquired;
    }
    /**
     * Returns number of unused connections in the pool
     */
    get idleConnections() {
        return this._pool.available;
    }
    /**
     * Returns total number of connections in the pool regardless of whether they are idle or in use
     */
    get totalConnections() {
        return this._pool.size;
    }
    /**
     * Obtains a connection from the connection pool
     */
    async acquire() {
        const intlCon = await this._pool.acquire();
        debug('acquired connection %s', intlCon.processID);
        return new Connection(this, intlCon);
    }
    /**
     * Shuts down the pool and destroys all resources.
     */
    async close(terminateWait) {
        const ms = terminateWait == null ? 10000 : terminateWait;
        return this._pool.closeAsync(ms);
    }
    /**
     * Executes a script
     */
    async execute(sql, options) {
        const connection = await this.acquire();
        try {
            return await connection.execute(sql, options);
        }
        finally {
            await this.release(connection);
        }
    }
    /**
     * Executes a query
     */
    async query(sql, options) {
        const connection = await this.acquire();
        try {
            return await connection.query(sql, options);
        }
        finally {
            await this.release(connection);
        }
    }
    async prepare(sql, options) {
        debug('prepare | %s', sql);
        const connection = await this.acquire();
        const statement = await connection.prepare(sql, options);
        statement.once('close', () => this._pool.release(getIntlConnection(connection)));
        return statement;
    }
    release(connection) {
        return this._pool.releaseAsync(getIntlConnection(connection));
    }
}
